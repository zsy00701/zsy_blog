---
title: 计算机算术运算
date: '2025-12-26T05:46:39.195Z'
excerpt: 加法器、乘法器与浮点运算的硬件实现
category: 计算机系统原理
---
# Arithmetic for Computers





## Full Adder

 输入为加数、被加数和低位进位Cin，输出为和F、进位Cout

## 串行进位加法器

- CarryOut = B&CarryIn | A &CarryIn | A&B
- Sum=A XOR B XOR CarryIn

- **基本结构**：n位串行进位加法器由 n 个全加器（FA）串联而成。
- **工作方式**：它通过逐级传递进位信号来实现加法运算。每个全加器的输入进位 Cin 来自于前一个低位全加器的输出进位 Cout。
- **进位传递**：进位信号按串行方式从最低位（C0）逐级传递到最高位（Cn），因此被称为“串行进位”或“行波”进位。

**缺点：**串行进位加法器的主要缺点是**速度慢**，因为它的运算速度受限于进位信号的串行传递延迟。

![image-20251226194513112](/Users/zhoushengyao/Library/Application Support/typora-user-images/image-20251226194513112.png)

**右下角问题的解释：**

$$\text{总延迟} = \text{等待进位的时间} + \text{最后一次异或的时间}（另一次已经算完了）$$

$$\text{总延迟} = (2n - 2) + 3$$

$$\text{总延迟} = 2n + 1$$

## 先行进位计算器（Carry Lookahead Adder,CLA)

### 两个关键信号：生成（G）与传播（P）

为了实现“并行计算”，我们需要重新定义每一位的状态。对于第 $i$ 位（输入 $A_i, B_i$）：

#### (1) 进位生成信号 (Generate, $G_i$)

- **定义**：$G_i = A_i \ \& \ B_i$
- **含义**：不管低位有没有进位传上来，只要 $A_i$ 和 $B_i$ 都是 1，我自己这一位**一定会产生（Generate）** 一个向高位的进位。

#### (2) 进位传播信号 (Propagate, $P_i$)

- **定义**：$P_i = A_i \ | \ B_i$ （有时也用异或 $A_i \oplus B_i$）
- **含义**：如果 $A_i$ 和 $B_i$ 中有一个是 1，那么如果低位有一个进位传上来，我就能把这个进位**传递（Propagate）** 给高位。
  - *就像导线一样，只要 $P_i$ 是真，进位就能穿过我。*

### 进位公式

- **$C_i$**：**进入**第 $i$ 位的进位（来自低位）。
- **$C_{i+1}$**：**离开**第 $i$ 位的进位（送往高位 $i+1$）。

标准的进位公式是：

$$C_{i+1} = G_i \ | \ (P_i \ \& \ C_i)$$

(意思：要么我自己产生进位，要么低位有进位且我帮它传下去)

现在我们要**展开**这个公式，把中间过程“消掉”：

- 第1位进位 $C_1$：

  $$C_1 = G_0 \ | \ (P_0 \ \& \ C_0)$$

- 第2位进位 $C_2$：

  原公式：$C_2 = G_1 \ | \ (P_1 \ \& \ \mathbf{C_1})$

  把上面的 $C_1$ 代入：

  $$C_2 = G_1 \ | \ (P_1 \ \& \ [G_0 \ | \ (P_0 \ \& \ C_0)])$$

  展开后：

  $$C_2 = G_1 \ | \ (P_1 \ \& \ G_0) \ | \ (P_1 \ \& \ P_0 \ \& \ C_0)$$

- 第3位进位 $C_3$：

  同理代入，你会得到：

  $$C_3 = G_2 \ | \ (P_2 G_1) \ | \ (P_2 P_1 G_0) \ | \ (P_2 P_1 P_0 C_0)$$

- 第4位进位 $C_4$：

  $$C_4 = G_3 \ | \ (P_3 G_2) \ | \ (P_3 P_2 G_1) \ | \ (P_3 P_2 P_1 G_0) \ | \ (P_3 P_2 P_1 P_0 C_0)$$

仔细看 $C_4$ 的公式：它只包含了 $G$、$P$（这些由 $A$、$B$ 直接算出）和 $C_0$

结论： 计算 $C_4$ 不需要等待 $C_3$、$C_2$、$C_1$ 算出！只要电路一通电，$C_4$ 的逻辑门可以直接利用原始输入 $A, B, C_0$ 瞬间算出结果。

### 局部（单级）先行进位加法器

![image-20260103074858470](https://raw.githubusercontent.com/zsy00701/typora-images/main/image-20260103074858470.png)

#### 第一步：第一个数字 **3** （产生第一个进位 $C_8$）

- 这是**第1个8位加法器**产生进位输出 $C_8$ 所需的时间。
- **分解：**
  1. **1级延迟：** 先根据输入 A 和 B，生成内部的 $G$（生成）和 $P$（传递）信号。
  2. **2级延迟：** 利用 $G$ 和 $P$ 以及 $C_0$，通过逻辑电路算出 $C_8$。
- **合计：** $1 + 2 = 3$ 级延迟。
- *此时， $C_8$ 已经准备好了，传给第二个盒子。*

#### 第二步：第二个数字 **2** （产生第二个进位 $C_{16}$）

- 这是**第2个8位加法器**产生 $C_{16}$ 的时间。
- **为什么只有2？前面不是3吗？**
  - 因为当 $C_8$ 还在路上跑的时候，第2个盒子里的 $A$ 和 $B$ 早就到了，内部的 $G$ 和 $P$ 信号（需要1级延迟那个）**早就已经算好在等了**。
  - 所以，第2个盒子只需要等待 $C_8$ 一到，马上通过进位链逻辑（2级延迟）算出 $C_{16}$。
- **合计：** 2 级延迟。

#### 第三步：第三个数字 **2** （产生第三个进位 $C_{24}$）

- 同理，**第3个8位加法器**产生 $C_{24}$ 的时间。
- 内部 $G, P$ 早就好了，只等 $C_{16}$ 一到，经过2级门电路，算出 $C_{24}$。
- **合计：** 2 级延迟。

#### 第四步：第四个数字 **5** （产生最终结果 Sum）

- 这是**最后这个加法器**收到进位 $C_{24}$ 后，算出最终结果（尤其是最高位的结果）所需的时间。

- **分解（推测PPT的计算逻辑）：**

  1. $C_{24}$ 到达。
  2. **2级延迟：** 即使在块内部是先行进位，由于块比较大（8位），内部可能还需要级联或者经过特定的逻辑层级来产生块内的最高位进位（比如 $C_{30}$ 或 $C_{31}$ 的内部前置信号）。通常这被视为内部进位生成时间。
  3. **3级延迟：** 最后计算和（Sum）通常是一个异或运算（XOR）。在晶体管级别，异或门比与门/或门复杂，有时被计为3级门延迟。

  - *注：这里具体的 "5" 是教材约定的经验值。意思是：进位到了之后，块内还需要 5 个单位时间才能稳定输出所有的和。*

![image-20260103075518255](https://raw.githubusercontent.com/zsy00701/typora-images/main/image-20260103075518255.png)

## n位整数加/减运算器

![image-20260103075600509](https://raw.githubusercontent.com/zsy00701/typora-images/main/image-20260103075600509.png)

### overflow

![image-20260103075645459](https://raw.githubusercontent.com/zsy00701/typora-images/main/image-20260103075645459.png)

## Arithmetic for Multimedia（多媒体算术运算）

![image-20260103080228960](https://raw.githubusercontent.com/zsy00701/typora-images/main/image-20260103080228960.png)

![image-20260103125151518](https://raw.githubusercontent.com/zsy00701/typora-images/main/image-20260103125151518.png)

 ![image-20260103125715832](https://raw.githubusercontent.com/zsy00701/typora-images/main/image-20260103125715832.png)
